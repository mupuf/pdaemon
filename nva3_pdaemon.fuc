/*
 *                               - PDAEMON -
 *
 * This code is meant to be run in PDAEMON. It exports some services to the
 * Host and does some operations such as fan management on its own.
 * Each operations are done in separated "process". Up to 16 process can
 * execute simultaneously.
 *
 * Some parts of this code are based on Maarten Lankhorst's previous work.
 *
 * = Calling conventions =
 * The calling conventions are simple:
 * - $r0 = 0
 * - Function parameters are passed in $r10-15
 * - Return value is passed in $r10
 * - A function shouldn't modify $r0-$r9 unless it restores their original
 * 	values afterwards (push/pop)
 * - That's it for now
 *
 * = Processes =
 * Each process is composed of:
 * - A PID (not actually stored anywhere but in #dispatch_pid_table
 * - Name of the process: First 10 bytes of the dedicated address space
 * - a command handler: referenced by #dispatch_pid_table to map pid <-> handler
 * - more to come!
 *
 * = Host -> pdaemon communication =
 * The host can send commands to each process:
 * - A ring buffer of 16 entries is operated by the classic FIFO_GET/PUT combo
 * - Each entry is composed of:
 * 	- u4: pid		// process who should receive this command
 * 	- u12: cmd_size		// size of the command buffer
 * 	- u16: cmd_ptr		// pointer to some place in the data section
 * - the command pointer should point to some place located in
 * 	[dispatch_data, ptr_fan_name[
 * - commands are process-specific and are documented inside the
 * 	process's dispatch function.
 *
 * Author: Martin Peres <martin.peres@labri.fr>
 */


/*
 * some notes to self about the envyas/fuc syntax:
 * - You cannot load a 32 bits immediate into a reg, you need to do:
 * 	movw $rx (value & 0xffff)
 * 	sethi $rx (value & 0xffff0000)
 *
 * - Indexed access (I[$rx + imm]). imm is limited to 0x3fc.
 */

/* store some important pointers */
section #nva3_pdaemon_ptrs
ptr_data_stack_begin: b32 #stack_begin
ptr_data_stack_end: b32 #stack_end
ptr_dispatch_pid_table: b32 #dispatch_pid_table
ptr_dispatch_ring: b32 #dispatch_ring
ptr_dispatch_data: b32 #dispatch_data
ptr_fan_name: b32 #fan_name
ptr_hwsq_name: b32 #hwsq_name


section #nva3_pdaemon_data
/* memory map
 * start	stop		purpose
 * ------------------------------------
 * 0x0		0x400		stack
 * 0x400	0x800		dispatch
 * 0x800	0x900		fan_mgmt
 * 0x900	0x1000		hwsq
 */
/* stack */
stack_begin: b8 0xfe
skip 0x3fb
stack_end: b32 0xdeadcafe

/* dispatch */
dispatch_pid_table:	b32 0x00 #fan_dispatch #hwsq_dispatch 0x00
			b32 0x00 0x00 0x00 0x00
			b32 0x00 0x00 0x00 0x00
			b32 0x00 0x00 0x00 0x00

dispatch_ring:		b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff

dispatch_data: b32 0xdeadbeef
align 0x400

/* fan_mgmt */
fan_name: b8 0x66 0x61 0x6e 0x5f 0x6d 0x67 0x6d 0x74 0x0 0x0 /* fan_mgmt */
align 0x100

/* hwsq */
hwsq_name: b8 0x68 0x77 0x73 0x71 0x0 0x0 0x0 0x0 0x0 0x0 0x0 /* hwsq */
align 0x100


section #nva3_pdaemon_code
init:
	/* force $r0 to 0 */
	clear b32 $r0

	/* set the stack pointer */
	mov $r1 #stack_end
	mov $sp $r1

	/* set the interrupt vectors */
	mov $r1 #iv
	mov $iv0 $r1
	mov $iv1 $r1
	
	// mmio_wr(FIFO_PUT, dispatch_ring)
	movw $r10 0xa4a0
	sethi $r10 0x100000
	mov $r11 #dispatch_ring
	call #mmwrs

	// mmio_wr(FIFO_GET, dispatch_ring)
	movw $r10 0xa4b0
	sethi $r10 0x100000
	mov $r11 #dispatch_ring
	call #mmwrs

	/* route all IRQs to the fuc vector 0: iowr(INTR_ROUTING, 0x0) */
	mov $r1 0x700
	sethi $r1 0x0
	clear b32 $r2
	iowrs I[$r1] $r2

	/* enable FIFO interrupts: iowr(INTR_EN_SET, 0x800) */
	mov $r1 0x400
	sethi $r1 0x0
	movw $r2 0x800
	sethi $r2 0x0
	iowrs I[$r1] $r2

	/* enable interrupts on FIFO 0: mmwrs(FIFO_INTR_EN, 0x1) */
	movw $r10 0xa4c4
	sethi $r10 0x100000
	movw $r11 0x1
	sethi $r11 0x0
	call #mmwrs

	/* deactivate traps and activate iv0/1 */
	bclr $flags ta
	bset $flags ie0
	bset $flags ie0

	bra #main
	exit

/* Interrupt handler
 * In: 	None
 * Out:	None
 */
iv:
	/* save the current context */
	push $r1
	push $r2
	push $r3
	push $r4
	push $r5
	push $r6
	push $r7
	push $r8
	push $r9
	push $r10
	push $r11
	push $r12
	push $r13
	push $r14
	push $r15
	mov $r1 $flags
	push $r1

	/* TODO: deactivate IRQs */

	/* $r1 = iord(INTR) */
	iord $r1 I[$r0 + 0x200]

	/* $r2 = mmio_rd(0x10a688) */
	movw $r10 0xa688
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r2 $r10

	/* TODO: reactivate IRQs */

	/* TODO: Actually check if we should call dispatch :D */

	call #dispatch

	/* TODO: Maybe dispatch should ACK the IRQ on its own, ideas? */

	/* TODO: deactivate IRQs */

	/* ack FIFO_PENDING */
	movw $r10 0xa4c0
	sethi $r10 0x100000
	mov $r11 1
	call #mmwrs

	/* ack the subirq */
	movw $r10 0xa668
	sethi $r10 0x100000
	clear b32 $r11
	call #mmwrs

	/* ack the IRQ */
	mov $r3 -1
	iowrs I[$r0 + 0x100] $r3

	/* TODO: reactivate IRQs */

	/* restore the context */
	pop $r1
	mov $flags $r1
	pop $r15
	pop $r14
	pop $r13
	pop $r12
	pop $r11
	pop $r10
	pop $r9
	pop $r8
	pop $r7
	pop $r6
	pop $r5
	pop $r4
	pop $r3
	pop $r2
	pop $r1

	iret

/* mmio sync:
 * In:	None
 * Out:	None
 */
mmsync:
	mov $r9 0
	mmloop_:
		movw $r15 0xeb00
		sethi $r15 0x10000
		iord $r15 I[$r15]
		add b32 $r9 $r9 1
		extr $r15 $r15 12:14
		bra nz #mmloop_
	ret

/* mmio write sync:
 * In: 	$r10: addr
 * 	$r11: value
 * Out:	None
 */
mmwr:
	call #mmsync
	movw $r15 0xe800
	sethi $r15 0x10000
	iowr I[$r15] $r10
	add b32 $r15 0x100
	iowr I[$r15] $r11
	add b32 $r15 0x200
	mov $r11 0xf2
	sethi $r11 0x10000
	iowr I[$r15] $r11
	iord $r11 I[$r15]
	ret

/* mmio write sync:
 * In: 	$r10: addr
 * 	$r11: value
 * Out:	None
 */
mmwrs:
	call #mmwr
	call #mmsync
	ret

/* mmio read:
 * In: 	$r10: addr
 * Out:	$r10: value
 */
mmrd:
	call #mmsync
	movw $r15 0xe800
	sethi $r15 0x10000
	iowr I[$r15] $r10
	add b32 $r15 0x300
	mov $r11 0xf1
	sethi $r11 0x10000
	iowr I[$r15] $r11
	iord $r11 I[$r15]
	call #mmsync
	movw $r15 0xe900
	sethi $r15 0x10000
	iord $r10 I[$r15]
	ret
	
/* chipset
 * In: 	None
 * Out:	$r10: the chipset
 */
chipset:
	clear b32 $r10
	call #mmrd
	shr b32 $r10 $r10 20
	and $r10 $r10 0xff
	ret

/* dispatch: read from the dispatch ring buffer
 * In: 	None
 * Out:	None
 */
dispatch:
	// $r1 = mmio_rd(FIFO_PUT, 0)
	movw $r10 0xa4a0
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r1 $r10

	// $r2 = mmio_rd(FIFO_GET, 0)
	movw $r10 0xa4b0
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r2 $r10

	/* if FIFO_PUT == FIFO_GET then exit */
	cmpu b32 $r2 $r1
	bra e #dispatch_exit

	/* $r3 = get the pid at FIFO_GET */
	clear b32 $r3
	ld b8 $r3 D[$r2 + 3]
	shr b8 $r3 4

	/* $r5 = dispatch_pid_table[pid] */
	clear b32 $r4
	movw $r4 #dispatch_pid_table	// $r4 = dispatch_pid_table
	clear b32 $r5
	mov b8 $r5 $r3
	shl b8 $r5 $r5 2		// $r5 = pid * 4
	add b32 $r4 $r5			// $r4 = addr of dispatch_pid_table[pid]
	ld b32 $r5 D[$r4]		// $r5 = *$r4

	/* if $r5 then $r5() */
	mov b32 $r10
	call $r5

	/* bump FIFO_GET: mmio_wr(FIFO_GET, dispatch_ring + ($r2 + 4) % 0x40) */
	movw $r10 0xa4b0
	sethi $r10 0x100000
	mov b32 $r11 $r2
	add b32 $r11 0x4
	mod $r11 $r11 0x40
	add b32 $r11 #dispatch_ring
	call #mmwrs

	/* loop */
	bra #dispatch

dispatch_exit:
	ret

/* fan_dispatch: fan_mgmt's dispatch handler
 * In: 	$r10: command's header
 * Out:	None
 */
fan_dispatch:
	mov $r10 5
	st b8 D[$r0 + 1]  $r10		// debug
	ret

/* hwsq_dispatch: hwsq's dispatch handler
 * In: 	$r10: command's header
 * Out:	None
 */
hwsq_dispatch:
	mov $r10 6
	st b8 D[$r0 + 1] $r10		// debug
	ret

/* main:
 * In: 	None
 * Out:	None
 */
main:
	/* tight looooooooooooooooooooooop */
	bra #main
align 256
