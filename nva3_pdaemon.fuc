/*
 *                               - PDAEMON -
 *
 * This code is meant to be run in PDAEMON. It exports some services to the
 * Host and does some operations such as fan management on its own.
 * Each operations are done in separated "processes". Up to 16 process can
 * execute simultaneously.
 *
 * Some parts of this code are based on Maarten Lankhorst's previous work.
 *
 * = Calling conventions =
 * The calling conventions are simple
 * - $r0 = 0
 * - Function parameters are passed in $r10-15
 * - Return value is passed in $r10
 * - A function shouldn't modify $r0-$r9 unless it restores their original
 * 	values afterwards (push/pop)
 * - That's it for now
 *
 * = Processes =
 * Each process is composed of:
 * - A PID (not actually stored anywhere but in #dispatch_pid_table
 * - Name of the process: First 10 bytes of the dedicated address space
 * - a command handler: referenced by #dispatch_pid_table to map pid <-> handler
 * - more to come!
 *
 * = Host -> pdaemon communication =
 * The host can send commands to each process:
 * - A ring buffer of 16 entries is operated by the classic FIFO_GET/PUT combo
 * - Each entry is composed of:
 * 	- u4: pid		// process who should receive this command
 * 	- u12: cmd_size		// size of the command buffer
 * 	- u16: cmd_ptr		// pointer to some place in the data section
 * - the command pointer should point to some place located in
 * 	[dispatch_data, ptr_fan_name[
 * - commands are process-specific and are documented inside the
 * 	process's dispatch function.
 *
 * Some processes may want to expose their address space so as the host can
 * change some parameters. It is done by writing a header at position 0 of the
 * memory area pointed by cmd_ptr. Some memory space should also be allocated to
 * store the value to be read/set. The header format is:
 * 	- u1: type (get = 0, set = 1)
 * 	- u15: value size
 * 	- u16 resource_id
 *
 * = Pdaemon -> host communication =
 * TODO
 *
 * Author: Martin Peres <martin.peres@labri.fr>
 */


/*
 * some notes to self about the envyas/fuc syntax:
 * - You cannot load a 32 bits immediate into a reg, you need to do:
 * 	movw $rx (value & 0xffff)
 * 	sethi $rx (value & 0xffff0000)
 *
 * - Indexed access (I[$rx + imm]). imm is limited to 0x3fc.
 */

/* store some important pointers */
section #nva3_pdaemon_ptrs
ptr_data_stack_begin: b32 #stack_begin
ptr_data_stack_end: b32 #stack_end
ptr_dispatch_pid_table: b32 #dispatch_pid_table
ptr_dispatch_ring: b32 #dispatch_ring
ptr_dispatch_data: b32 #dispatch_data
ptr_rdispatch_ring: b32 #rdispatch_ring
ptr_fan_name: b32 #fan_name
ptr_hwsq_name: b32 #hwsq_name


section #nva3_pdaemon_data
/* memory map
 * start	stop		purpose
 * ------------------------------------
 * 0x0		0x400		stack
 * 0x400	0x800		dispatch
 * 0x800	0xa00		rdispatch
 * 0xa00	0xb00		fan_mgmt
 * 0xb00	0xc00		hwsq
 */
/* stack */
stack_begin: b8 0xfe
skip 0x3fb
stack_end: b32 0xdeadcafe

/* dispatch */
dispatch_pid_table:	b32 0x00 #fan_dispatch #hwsq_dispatch 0x00
			b32 0x00 0x00 0x00 0x00
			b32 0x00 0x00 0x00 0x00
			b32 0x00 0x00 0x00 0x00

dispatch_ring:		b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff
			b32 0xff 0xff 0xff 0xff

dispatch_data: b32 0xdeadbeef
align 0x400

/* rdispatch */
rdispatch_ring: b32 0xdeadbabe
skip 0x1fc

/* fan_mgmt */
fan_name: b8 0x66 0x61 0x6e 0x5f 0x6d 0x67 0x6d 0x74 0x0 0x0 0x0 0x0 /* fan_mgmt */
align 0x100

/* hwsq */
hwsq_name: b8 0x68 0x77 0x73 0x71 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 0x0 /* hwsq */
align 0x100


section #nva3_pdaemon_code
init:
	/* force $r0 to 0 */
	clear b32 $r0

	/* set the stack pointer */
	mov $r1 #stack_end
	mov $sp $r1

	/* set the interrupt vectors */
	mov $r1 #isr
	mov $iv0 $r1
	mov $iv1 $r1

	// mmio_wr(FIFO_PUT, dispatch_ring)
	movw $r10 0xa4a0
	sethi $r10 0x100000
	mov $r11 #dispatch_ring
	call #mmwrs

	// mmio_wr(FIFO_GET, dispatch_ring)
	movw $r10 0xa4b0
	sethi $r10 0x100000
	mov $r11 #dispatch_ring
	call #mmwrs

	/* route all IRQs to the fuc vector 0: iowr(INTR_ROUTING, 0x0) */
	mov $r1 0x700
	sethi $r1 0x0
	clear b32 $r2
	iowrs I[$r1] $r2

	/* enable FIFO interrupts: iowr(INTR_EN_SET, 0x800) */
	mov $r1 0x400
	sethi $r1 0x0
	movw $r2 0x800
	sethi $r2 0x0
	iowrs I[$r1] $r2

	/* enable interrupts on FIFO 0: mmwrs(FIFO_INTR_EN, 0x1) */
	movw $r10 0xa4c4
	sethi $r10 0x100000
	movw $r11 0x1
	sethi $r11 0x0
	call #mmwrs

	/* deactivate traps and activate iv0/1 */
	bclr $flags ta
	bset $flags ie0
	bset $flags ie0

	bra #main
	exit

/* Interrupt handler
 * In: 	None
 * Out:	None
 */
isr:
	/* save the current context */
	push $r1
	push $r2
	push $r3
	push $r4
	push $r5
	push $r6
	push $r7
	push $r8
	push $r9
	push $r10
	push $r11
	push $r12
	push $r13
	push $r14
	push $r15
	mov $r1 $flags
	push $r1

	/* TODO: deactivate IRQs */

	/* $r1 = iord(INTR) */
	iord $r1 I[$r0 + 0x200]

	/* $r2 = mmio_rd(0x10a688) */
	movw $r10 0xa688
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r2 $r10

	/* line 11 ? */
	xbit $r3 $r1 11
	cmpu b8 $r3 1
	bra ne #isr_dispatch_next

	/* line 11: subline 1 ? */
	xbit $r3 $r2 1
	cmpu b8 $r3 1
	bra ne #isr_dispatch_next

	/* that's an internal FIFO IRQ */
	call #dispatch

isr_dispatch_next:
	/* reload the interrupt state to check we handled everything */
	iord $r1 I[$r0 + 0x200] // $r1 = iord(INTR)
	movw $r10 0xa688
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r2 $r10 // $r2 = mmio_rd(0x10a688)

	/* display the current interrupt state */
	/*st b32 D[$r0 + 4] $r1
	st b32 D[$r0 + 8] $r2*/

	/* ack all the IRQs */
	mov $r3 -1
	iowrs I[$r0 + 0x100] $r3

	/* TODO: reactivate IRQs */

	/* restore the context */
	pop $r1
	mov $flags $r1
	pop $r15
	pop $r14
	pop $r13
	pop $r12
	pop $r11
	pop $r10
	pop $r9
	pop $r8
	pop $r7
	pop $r6
	pop $r5
	pop $r4
	pop $r3
	pop $r2
	pop $r1

	iret

/* mmio sync:
 * In:	None
 * Out:	None
 */
mmsync:
	mov $r9 0
	mmloop_:
		movw $r15 0xeb00
		sethi $r15 0x10000
		iord $r15 I[$r15]
		add b32 $r9 $r9 1
		extr $r15 $r15 12:14
		bra nz #mmloop_
	ret

/* mmio write sync:
 * In: 	$r10: addr
 * 	$r11: value
 * Out:	None
 */
mmwr:
	call #mmsync
	movw $r15 0xe800
	sethi $r15 0x10000
	iowr I[$r15] $r10
	add b32 $r15 0x100
	iowr I[$r15] $r11
	add b32 $r15 0x200
	mov $r11 0xf2
	sethi $r11 0x10000
	iowr I[$r15] $r11
	iord $r11 I[$r15]
	ret

/* mmio write sync:
 * In: 	$r10: addr
 * 	$r11: value
 * Out:	None
 */
mmwrs:
	call #mmwr
	call #mmsync
	ret

/* mmio read:
 * In: 	$r10: addr
 * Out:	$r10: value
 */
mmrd:
	call #mmsync
	movw $r15 0xe800
	sethi $r15 0x10000
	iowr I[$r15] $r10
	add b32 $r15 0x300
	mov $r11 0xf1
	sethi $r11 0x10000
	iowr I[$r15] $r11
	iord $r11 I[$r15]
	call #mmsync
	movw $r15 0xe900
	sethi $r15 0x10000
	iord $r10 I[$r15]
	ret

/* chipset
 * In: 	None
 * Out:	$r10: the chipset
 */
chipset:
	clear b32 $r10
	call #mmrd
	shr b32 $r10 $r10 20
	and $r10 $r10 0xff
	ret

/* get_time
 * In: 	None
 * Out:	$r10: TIME_HIGH
 *      $r11: TIME_LOW
 */
get_time:
	/* $r11 = iord(TIME_HIGH) */
	clear b32 $r10
	movw $r10 0xc00
	iord $r11 I[$r10]

	/* $r12 = mmrd(TIME_LOW) */
	clear b32 $r10
	movw $r10 0xb00
	iord $r12 I[$r10]

	/* $r13 = mmrd(TIME_HIGH) */
	clear b32 $r10
	movw $r10 0xc00
	iord $r13 I[$r10]

	/* no overflow happened? */
	cmpu b32 $r11 $r13
	bra ne #get_time

	/* $r10 = TIME_HIGH; $r11 = TIME_LOW */
	mov b32 $r10 $r13
	mov b32 $r11 $r12
	ret

/* memcpy:
 * In: 	$r10: dst
 * 	$r11: src
 * 	$r12: length
 * Out:	None
 */
memcpy:
	/* return when length == 0 */
	cmpu b32 $r12 0
	bra e #memcpy_exit

	/* dst[0] = src[0] */
	ld b8 $r13 D[$r11]
	st b8 D[$r10] $r13

	/* inc $r10 and $r11 then dec $r12 */
	add b32 $r10 1
	add b32 $r11 1
	sub b32 $r12 1

	bra #memcpy
memcpy_exit:
	ret

/* strncpy:
 * In: 	$r10: dst
 * 	$r11: src
 * 	$r12: max_length
 * Out:	None
 */
strncpy:
	/* return when length == 0 */
	cmpu b32 $r12 0
	bra e #memcpy_exit

	/* dst[0] = src[0] */
	ld b8 $r13 D[$r11]
	st b8 D[$r10] $r13

	/* inc $r10 and $r11 then dec $r12 */
	add b32 $r10 1
	add b32 $r11 1
	sub b32 $r12 1

	/* if $r13 = '\0', return */
	cmpu b32 $r13 0
	bra e #memcpy_exit

	bra #memcpy
strncpy_exit:
	ret

// TODO: sleep, deferred task, periodic timer

/* dispatch: read from the dispatch ring buffer
 * In: 	None
 * Out:	None
 */
dispatch:
	// $r1 = mmio_rd(FIFO_PUT, 0)
	movw $r10 0xa4a0
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r1 $r10

	// $r2 = mmio_rd(FIFO_GET, 0)
	movw $r10 0xa4b0
	sethi $r10 0x100000
	call #mmrd
	mov b32 $r2 $r10

	/* if FIFO_PUT == FIFO_GET then exit */
	cmpu b32 $r2 $r1
	bra e #dispatch_exit

	/* $r3 = pid from FIFO_GET */
	clear b32 $r3
	ld b8 $r3 D[$r2 + 3]
	shr b8 $r3 4

	/* $r4 = packet size from FIFO_GET */
	clear b32 $r4
	ld b16 $r4 D[$r2 + 2]
	and $r4 0xfff

	/* $r5 = packet ptr from FIFO_GET */
	clear b32 $r5
	ld b16 $r5 D[$r2 + 0]


	/* $r6 = dispatch_pid_table[pid] */
	clear b32 $r7
	movw $r7 #dispatch_pid_table	// $r7 = dispatch_pid_table
	clear b32 $r6
	mov b8 $r6 $r3
	shl b8 $r6 $r6 2		// $r6 = pid * 4
	add b32 $r7 $r6			// $r7 = addr of dispatch_pid_table[pid]
	ld b32 $r6 D[$r7]		// $r6 = *$r7

	/* if $r6 then $r6() : call the dispatch method of the pid */
	mov b32 $r10 $r4
	mov b32 $r11 $r5
	call $r6

	/* bump FIFO_GET: mmio_wr(FIFO_GET, dispatch_ring + ($r2 + 4) % 0x40) */
	movw $r10 0xa4b0
	sethi $r10 0x100000
	mov b32 $r11 $r2
	add b32 $r11 0x4
	mod $r11 $r11 0x40
	add b32 $r11 #dispatch_ring
	call #mmwrs

	/* loop */
	bra #dispatch

dispatch_exit:
	/* ack FIFO_PENDING */
	movw $r10 0xa4c0
	sethi $r10 0x100000
	mov $r11 1
	call #mmwrs

	/* ack the dispatch IRQ */
	mov $r3 0x800
	iowrs I[$r0 + 0x100] $r3

	ret

/* dispatch_parse_cmd: parse command (get/set)
 * In: 	$r10: packet size
 * 	$r11: packet ptr
 * Out:	$r10: type (get/set) : get == 0, set == 1, error == 0xffffffff
 * 	$r11: resource_id
 * 	$r12: resource_size
 * 	$r13: resource_data
 */
dispatch_parse_cmd:
	/* check packet size and bail out if it is lower than 8 (2 words) */
	mov b32 $r12 $r10
	clear b32 $r10
	sub b32 $r10 $r10 1 // <-- $r10 = 0xffffffff
	cmpu b32 $r12 4
	bra g #dispatch_parse_cmd_exit
	mov b32 $r10 $r12

	/* read the cmd header */
	ld b32 $r14 D[$r11 + 0]

	/* get the resource data ptr (packet_ptr + 4) */
	add b32 $r13 $r11 4

	/* get the resource size */
	ld b16 $r12 D[$r11 + 2]
	bclr $r12 15 // mask the get/set bit

	/* get the resource id */
	ld b16 $r11 D[$r11 + 0]

	/* get the type (bit 31 of word 0) */
	xbit $r10 $r14 31

dispatch_parse_cmd_exit:
	ret

/* dispatch_exec_cmd: execute a command (get/set)
 * In:	$r10: type (get/set) : get == 0, set == 1, error == 0xffffffff
 * 	$r11: resource_id
 * 	$r12: resource_size
 * 	$r13; data_ptr
 * 	$r14: process' data base address
 * Out:	None
 */
dispatch_exec_cmd:
	/* is it a get command ? */
	cmpu b32 $r10 0
	bra e #dispatch_exec_cmd_get

	/* is it a set command ?*/
	cmpu b32 $r10 1
	bra e #dispatch_exec_cmd_set

	/* unknown command, bail out */
	movw $r10 0
	bra #dispatch_exec_cmd_exit

dispatch_exec_cmd_get:
	/* copy the resource to the destination: memcpy(dst=$r13, src=$r11+$r14, len=$r12) */
	mov b32 $r10 $r13
	add b32 $r11 $r14 $r11
	call #memcpy

	movw $r10 1
	bra #dispatch_exec_cmd_exit

dispatch_exec_cmd_set:
	/* copy the values to the destination: memcpy(dst=$r11+$r14, src=$r13, len=$r12) */
	add b32 $r10 $r14 $r11
	mov b32 $r11 $r13
	call #memcpy

	movw $r10 1
	bra #dispatch_exec_cmd_exit

dispatch_exec_cmd_exit:
	ret

/* fan_dispatch: fan_mgmt's dispatch handler
 * In: 	$r10: packet size
 * 	$r11: packet ptr
 * Out:	None
 */
fan_dispatch:
	/* parse the command header */
	call #dispatch_parse_cmd

	/* let's exec the command */
	movw $r14 #fan_name
	call #dispatch_exec_cmd

	ret

/* hwsq_dispatch: hwsq's dispatch handler
 * In: 	$r10: packet size
 * 	$r11: packet ptr
 * Out:	None
 */
hwsq_dispatch:
	/* parse the command header */
	call #dispatch_parse_cmd

	/* let's exec the command */
	movw $r14 #hwsq_name
	call #dispatch_exec_cmd
	ret

/* main:
 * In: 	None
 * Out:	None
 */
main:
	/* tight looooooooooooooooooooooop */
	bra #main
align 256
